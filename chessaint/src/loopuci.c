/* This file is part of the ChessAInt project 2015 */
/**
 * @file
 * @todo handle error with a real stderr file
 * @todo create functions to open/close files
 * @todo parse uci strings
 */

#include "include/loopuci.h"
#include "include/uci.h"
#include "include/astar.h"

/**
 *  Choose to use astar (set to 0) or not (set to 1)
 *
 */
#define RANDOM_MOVE 0

/**
 *  Choose to use cmdline mode or not, if 1,
 *  First move is played by using uci syntax :
 *  position x moves nnnn (where nnnn is the first white move Ex : e2e4)
 *  go s d a n x x
 *  where s d a n replace default values for :
 *  - query_score (5OO for mate)
 *  - depth (-1 for no limit)
 *  - astar_time (time in seconds)
 *  - nodes (-1 for no limit)
 *
 */
#define CMDLINE_MOD 1

/**
 * receive a uci string and act accordingly
 *
 * @return 0 if the gui stop
 * @return 1 otherwise
 */
int uciLoop(FILE* log, char* buffer, Graph *graph) {
  char uciBuffer[5] = "zzzz";
  char* word = NULL;

  /* log of the moves with cmdline mode */
  FILE *moveslog = fopen("moveslog", "a");
  setbuf(moveslog, NULL);

  /* Astar parameters */

  int query_score = 500;
  int depth = 5;
  int astar_time = 10;
  int stop = 0; /* do not change */
  int nodes = -1; /* the max number of nodes -1 <=> +inf */
  int ret = -1; /* do not change */

  receive(log, buffer);
  char* firstWord = getFirstWord(buffer);
  // strcmp second parameter
  // should end with \n if the word is the only one
  if (strcmp(firstWord, "uci\n") == 0) {
      send(log, "id name ChessAInt");
      send(log, "uciok");
  } else if (strcmp(firstWord, "isready\n") == 0) {
      send(log, "readyok");
  } else if (strcmp(firstWord, "ucinewgame\n") == 0) {
  } else if (strcmp(firstWord, "position") == 0) {
      word = getNextWord();  // "startpos"
      // put the root board in the "startpos" position
      initAGame(&graph->root);

      word = getNextWord();  // "moves"

      word = getNextWord();  // the first move

      if (CMDLINE_MOD) {
        time_t t = time(NULL);
        fprintf(moveslog, "%sHuman     : %d\n", ctime(&t), uciToMove(word));
      }

      while (getLastCharacter(word) != '\n') {
        play_move(uciToMove(word), &graph->root);
        word = getNextWord();
      }

      rmUCILastCharacter(word, uciBuffer);
      play_move(uciToMove(word), &graph->root);

  } else if (strcmp(firstWord, "go") == 0) {
      // ignore all these parameters but assume they exist
      word = getNextWord();  // "wtime"
      if (CMDLINE_MOD)
        query_score = atoi(word);
      word = getNextWord();  // number
      if (CMDLINE_MOD)
        depth = atoi(word);
      word = getNextWord();  // "btime"
      if (CMDLINE_MOD)
        astar_time = atoi(word);
      word = getNextWord();  // number
      if (CMDLINE_MOD)
        nodes = atoi(word);
      word = getNextWord();  // "movestogo"
      word = getNextWord();  // number

      graph->current_node = graph->root;

      graph->current_node.activeColor = black;

      // empty stack
      while (stack_pop(&(graph->current_moves)) != -1) {}

      int bestmove = 0;
      int a, b, c, d;

      if (RANDOM_MOVE) {
        movesGenerator(graph);
        bestmove = pickBestMove(&(graph->current_moves));
      } else {
        while (CMDLINE_MOD) { /* To play in cmdline mode */
          printBoardAndData(graph->root);
          ret = astar(graph, query_score, depth, astar_time,
                      nodes, &stop, &bestmove);
          printf("astar ret = %d\n", ret); /* to delete */

          graph->current_node = graph->root;
          play_move(bestmove, &(graph->root));

          stack_expand(&a, &b, &c, &d, bestmove);
          getUciString(a, b, c, d, uciBuffer);
          fprintf(moveslog, "ChessAint : %s\n", uciBuffer);
          printBoardAndData(graph->root);

          scanf("%s[5]", uciBuffer);
          bestmove = uciToMove(uciBuffer);

          fprintf(moveslog, "Human     : %s\n", uciBuffer);
          play_move(bestmove, &(graph->root));

          if (ret == 32)
            return 0;
        }
        ret = astar(graph, query_score, depth, astar_time,
                    nodes, &stop, &bestmove);
        if (ret == 32)
          return 0;
      }

      stack_expand(&a, &b, &c, &d, bestmove);
      getUciString(a, b, c, d, uciBuffer);

      char bestmoveString[20];
      snprintf(bestmoveString, sizeof(bestmoveString),
               "bestmove %s", uciBuffer);

      send(log, bestmoveString);

  } else if (strcmp(firstWord, "quit\n") == 0) {
      return 0;
  } else {}
  return 1;
}

/**
 * Choose a random move from the stack generated by
 * generateMoves
 */
int pickBestMove(Stack *current_moves) {
  int move = 0;
  for (int i = 0, rd = rand() % stack_length(*current_moves) ; i < rd + 1 ; ++i) //NOLINT
    move = stack_pop(current_moves);
  return move;
}

